<!--
Meta Description: # Rubyの「rescue」: エラーハンドリングの基本 ## 概要 Rubyにおける「rescue」は、例外処理を行うための構文であり、プログラムの実行中に発生したエラーをキャッチし、適切に対処するために使用されます。この機能により、プログラムのクラッシュを防ぎ、ユーザーに対してより良いエラーメ...
Meta Keywords: rescue, ruby, begin, end, puts
-->

# Rubyの「rescue」: エラーハンドリングの基本

## 概要
Rubyにおける「rescue」は、例外処理を行うための構文であり、プログラムの実行中に発生したエラーをキャッチし、適切に対処するために使用されます。この機能により、プログラムのクラッシュを防ぎ、ユーザーに対してより良いエラーメッセージを提供することが可能です。

## ドキュメンテーション
「rescue」は、beginブロック内で発生した例外を捕捉するために使用されます。基本的な構文は以下の通りです。

```ruby
begin
  # エラーが発生する可能性のあるコード
rescue SomeErrorClass => e
  # エラーハンドリングのコード
end
```

### 目的
「rescue」を使用することで、プログラムのエラー処理を簡潔に行うことができ、エラー発生時の挙動を制御することができます。

### 使用法
- **基本的な使用法**: beginブロック内にエラーが発生する可能性のあるコードを記述し、rescueブロックでそのエラーを捕捉します。
- **特定のエラーを捕捉**: 特定のエラークラスを指定することで、特定のエラーのみを処理することができます。
- **全てのエラーを捕捉**: 引数なしでrescueを使用すると、全ての例外を捕捉することができます。

## 例
以下に、基本的な使用例を示します。

### 例1: 基本的なエラーハンドリング

```ruby
begin
  1 / 0
rescue ZeroDivisionError => e
  puts "エラーが発生しました: #{e.message}"
end
```

### 例2: 特定のエラーを捕捉

```ruby
begin
  File.open("non_existent_file.txt")
rescue Errno::ENOENT => e
  puts "ファイルが見つかりません: #{e.message}"
end
```

### 例3: 全てのエラーを捕捉

```ruby
begin
  raise "何らかのエラー"
rescue => e
  puts "エラーが発生しました: #{e.message}"
end
```

## 説明
- **共通の落とし穴**: rescueを使用する際、特定のエラーを指定しない場合、全ての例外を捕捉してしまうため、予期しないエラーが隠れてしまうことがあります。
- **スタックトレースの確認**: エラー発生時にスタックトレースを確認することができるため、デバッグに役立ちます。`rescue`ブロック内で`puts e.backtrace`を使用すると、エラー発生時のトレースを表示できます。
- **ensure句の活用**: 必要に応じて、`ensure`句を使用することで、エラーの有無に関わらず実行するコードを指定できます。

## 一文の要約
Rubyの「rescue」は、プログラムの実行中に発生するエラーを捕捉し、適切に処理するための強力なエラーハンドリング機能です。